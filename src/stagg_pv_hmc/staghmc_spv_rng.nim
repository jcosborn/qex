#[ ~~~~ Imports ~~~~ ]#

import qex # QEX
import streams # For reading/writing

#[ ~~~~ Define constants for IO ~~~~ ]#

const
   # Info to be recorded in RNG file
   fileMd = "<?xml version=\"1.0\"?>\n<note>generated by QEX</note>\n"

   # More info to be recorded in RNG file
   recordMd = "<?xml version=\"1.0\"?>\n<note>RNG field</note>\n"

#[ ~~~~ Definition of RNG objects ~~~~ ]#

#[ Define global RNG object ]#
type GlobalRNG* = object
   rng_type*: string
   milc: RngMilc6
   mrg32k3a: MRG32k3a

#[ Define RNG field object ]#
type ParallelRNG* = object
   rng_type*: string
   milc*: typeof(Field[1, RngMilc6])
   mrg32k3a*: typeof(Field[1, MRG32k3a])

#[ ~~~~ Define global RNG object methods ~~~~ ]#

#[ Seed method ]#
proc seed*(R: var GlobalRNG; seed: uint64) =
   # Start case
   case R.rng_type:
      of "RngMilc6":
         # Do manipulation
         R.milc.seed(seed, 987654321)
      of "MRG32k3a":
         # Do manipulation
         R.mrg32k3a.seed(seed, 987654321)

#[ Sample method ]#
proc uniform*(R: var GlobalRNG): float32 =
   # Define random number
   var rnd_nm: float32

   # Start case
   case R.rng_type:
      of "RngMilc6":
         # Do manipulation
         rnd_nm = R.milc.uniform()
      of "MRG32k3a":
         # Do manipulation
         rnd_nm = R.mrg32k3a.uniform()

   # Return uniform
   result = rnd_nm

#[ Read method ]#
proc read_rng*(R: var GlobalRNG; base_fn: string) =
   # Define filename
   let fn = base_fn & ".global_rng"

   # Create new file stream
   var file = newFileStream(fn, fmRead)

   # Check to make sure that file exists
   if file == nil:
      # Quit program
      quit("Was not able to read " & fn & ". File does not exist. Exiting.")
   else:
      # Start case
      case R.rng_type:
         of "RngMilc6":
            # Read in RngMilc6 object
            discard file.readData(R.milc.addr, R.milc.sizeof)
         of "MRG32k3a":
            # Read in MRG32k3a object
            discard file.readData(R.mrg32k3a.addr, R.mrg32k3a.sizeof)

      # Tell user what you did
      echo "Read " & fn & " with format " & R.rng_type

#[ Write method ]#
proc write_rng*(R: var GlobalRNG; base_fn: string) =
   # Define filename
   let fn = base_fn & ".global_rng"

   # Create new file stream
   var file = newFileStream(fn, fmWrite)
   
   # Check if nil
   if not file.isNil:
      # Start case
      case R.rng_type:
         of "RngMilc6":
            # Write RngMilc6 object
            file.write R.milc
         of "MRG32k3a":
            # Write MRG32k3a object
            file.write R.mrg32k3a

      # Tell user what your did
      echo "Wrote " & fn & " with format " & R.rng_type
   else:
      # Tell user that there was an issue
      quit("Was not able to write " & fn)

   # Flush
   file.flush

#[ ~~~~ Define RNG field object methods ~~~~ ]#

#[ For initializing global RNG ]#
proc init_parallel_rng*(r: var ParallelRNG; lo: Layout; 
                        rng_type: string; seed: uint64) =
   # Set rng type
   r.rng_type = rng_type

   # Start case
   case r.rng_type:
      of "RngMilc6": r.milc = lo.newRNGField(RngMilc6, seed)
      of "MRG32k3a": #r.mrg32k3a = lo.newRNGField(MRG32k3a, seed)
         # Warn user and quit
         quit("MRG32k3a w/ I/O no longer supported for RNG fields. Workaround in progress.")

#[ For random sample ]#
proc random*(g: auto, r: var ParallelRNG) =
   # Start case
   case r.rng_type:
      of "RngMilc6": g.random(r.milc)
      of "MRG32k3a": g.random(r.mrg32k3a)

#[ For reading RNG ]#
proc read_rng*(r: var ParallelRNG; rng_fn: string) =
   # Start case
   case r.rng_type:
      of "RngMilc6":
         # Create reader for RNG field
         var reader = r.milc.l.newReader(rng_fn)

         # Read RNG file and store in RNG field
         reader.read(r.milc)

         # Close reader
         reader.close()
      of "MRG32k3a":
          # Give user temporary warning
          quit("MRG32k3a no longer supported for RNG fields. Workaround in progress.")
#         # Create reader for RNG field
#         var reader = r.mrg32k3a.l.newReader(rng_fn)

#         # Read RNG file and store in RNG field
#         reader.read(r.mrg32k3a)

#         # Close reader
#         reader.close()

#[ For writing RNG ]#
proc write_rng*(r: ParallelRNG; rng_fn: string) = 
   # Start case
   case r.rng_type:
      of "RngMilc6":
         # Create writer
         var writer = r.milc.l.newWriter(rng_fn, fileMd)

         # Write RNG field
         writer.write(r.milc, recordMd)

         # Close writer
         writer.close()
      of "MRG32k3a":
          # Tell user that MRG32k3a not currently supported
          quit("MRG32k3a no longer supported for RNG fields. Workaround in progress.")

#         # Create writer
#         var writer = r.mrg32k3a.l.newWriter(rng_fn, fileMd)

#         # Write RNG field
#         writer.write(r.mrg32k3a, recordMd)

#         # Close writer
#         writer.close()