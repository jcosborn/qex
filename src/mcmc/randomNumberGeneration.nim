import qex
import streams # For reading/writing
import strformat, strutils

const
  fileMd = "<?xml version=\"1.0\"?>\n<note>generated by QEX</note>\n"
  recordMd = "<?xml version=\"1.0\"?>\n<note>RNG field</note>\n"

type
  RandomNumberGeneratorType* = enum MILC, MRG

  RandomNumberGenerator {.inheritable.} = object
    generator: RandomNumberGeneratorType
    seed: uint64

  ParallelRNG* = object of RandomNumberGenerator
    milc*: typeof(Field[1, RngMilc6])
    mrg*: typeof(Field[1, MRG32k3a])

  SerialRNG* = object of RandomNumberGenerator
    milc*: RngMilc6
    mrg*: MRG32k3a

converter toRNGType*(s: string):
  RandomNumberGeneratorType = parseEnum[RandomNumberGeneratorType](s)

proc new(self: var RandomNumberGenerator; generator: string; seed: uint64) =
  case generator:
    of "MILC", "RngMilc6": self.generator = MILC 
    of "MRG", "MRG32k3a": self.generator = MRG
    else: qexError generator, " not supported"
  self.seed = seed

proc newParallelRNG*(
    l: Layout;
    generator: string;
    seed: uint64;
  ): ParallelRNG =
  new(result, generator, seed)
  case result.generator:
    of MILC: result.milc = l.newRNGField(RngMilc6, result.seed)
    of MRG: result.mrg = l.newRNGField(MRG32k3a, result.seed)

proc seed*(self: var SerialRNG) =
  case self.generator:
    of MILC: self.milc.seed(self.seed, 987654321)
    of MRG: self.mrg.seed(self.seed, 987654321)

proc newSerialRNG*(generator: string; seed: uint64): SerialRng =
  new(result, generator, seed)
  result.seed()

proc uniform*(self: var SerialRNG): float32 =
  case self.generator:
    of MILC: result = self.milc.uniform()
    of MRG: result = self.mrg.uniform()

proc readRNG*(self: var SerialRNG; fn: string) =
  var file = newFileStream(fn, fmRead)
  if file.isNil:
    qexError "Was not able to read ", fn,  ". File does not exist. Exiting."
  else:
    case self.generator:
      of MILC: discard file.readData(self.milc.addr, self.milc.sizeof)
      of MRG: discard file.readData(self.mrg.addr, self.mrg.sizeof)

proc writeRNG*(self: var SerialRNG; fn: string) =
  var file = newFileStream(fn, fmWrite)
  if file.isNil: qexError "Unable to write to ", fn,  ". Exiting."
  else:
    case self.generator:
      of MILC: file.write self.milc
      of MRG: file.write self.mrg
  file.flush

proc random*(self: var ParallelRNG; u: auto) =
  case self.generator:
    of MILC: u.random(self.milc)
    of MRG: u.random(self.mrg)

proc warm*(self: var ParallelRNG; u: auto) = 
  case self.generator:
    of MILC: warm(u, 0.5, self.milc)
    of MRG: warm(u, 0.5, self.mrg)

proc readRNG*(self: var ParallelRNG; filename: string) =
  case self.generator:
    of MILC:
      var reader = self.milc.l.newReader(filename)
      reader.read(self.milc)
      reader.close()
    of MRG: qexError "MRG32k3a not currently supported for IO"

proc writeRNG*(self: var ParallelRNG; filename: string) =
  case self.generator:
    of MILC:
      var writer = self.milc.l.newWriter(filename, fileMd)
      writer.write(self.milc, recordMd)
      writer.close()
    of MRG: qexError "MRG32k3a not currently supported for IO"

proc randomTAHGaussian(lu: auto; pRNG: auto) =
  threads:
    for mu in 0..<lu.len: lu[mu].randomTAH(pRNG)

proc randomTAHGaussian*(self: ParallelRNG; lu: auto) =
  case self.generator:
    of MILC: lu.randomTAHGaussian(self.milc)
    of MRG: lu.randomTAHGaussian(self.mrg)

proc randomComplexGaussian*(self: ParallelRNG; bosonField: auto) =
  case self.generator:
    of MILC:
      threads: bosonField.gaussian(self.milc)
    of MRG:
      threads: bosonField.gaussian(self.mrg)

when isMainModule:
  qexinit()

  # Create lattice layout
  let
    lat = intSeqParam("lat", @[4, 4, 4, 4])
    lo = lat.newLayout(@[1, 1, 1, 1])

  # Create objects RNG objects
  var
    pMILC = lo.newParallelRNG("MILC", 987654321)
    pMRG = lo.newParallelRNG("MRG", 987654321)
    sMILC = newSerialRNG("MILC", 987654321)
    sMRG = newSerialRNG("MRG", 987654321)

  # Print out serial RNG
  echo "serial uniform: ", sMILC.uniform(), " ", sMRG.uniform()

  # Test IO on serial RNG
  let nsample = 100
  sMILC.writeRNG("test.global_rng")
  for sample in 0..<nsample: discard sMILC.uniform()
  var sMILC2 = newSerialRNG("MILC", 987654321)
  sMILC2.readRNG("test.global_rng")
  for sample in 0..<nsample: discard sMILC2.uniform()
  echo sMILC.uniform(), " ", sMILC2.uniform()

  qexfinalize()